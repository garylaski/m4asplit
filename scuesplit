#!/bin/sh

#Check if ffmpeg is in $PATH and executable
[ -x $(command -v ffmpeg) ] || echo "ffmpeg is not installed" || exit 1

#ensure first param is a readable file
[ -r "$1" ] || echo "input a path to a readable file" || exit 1

#ensure second param is cue
[ -r "$2" ] && [ "$2" == "*.cue" ] || echo "input a path to an cue file" || exit 1

#extract audio file extension 
ext="${1##*.}"

#since cue files use HH:MM:FF where FF is frames out of 75, conversion to HH:MM.SS that ffmpeg needs
convert_to_ms() {
	prefix=$(echo $1 | head -c 5)
	frames=$(echo $1 | tail -c 3)
	frames=${frames##0}
	frames=$(($frames * 100 / 75))
	printf $prefix.$frames
}
#Iterate over cue file
while IFS= read -r line || [ -n "$line" ]; do
	#Remove leading whitespace
	trim=${line#${line%%[![:space:]]*}}
	#What does out line start with
	case $trim in
		TRACK*AUDIO)
			track_num=${trim##TRACK\ }
			track_num=${track_num%%AUDIO}
			continue;;
		TITLE\ *)
			title=${trim##TITLE\ }
			continue;;
		INDEX\ 00*)
			end_time=$(convert_to_ms ${trim##INDEX\ 00\ })
			[ $index -eq 1 ] && ffmpeg -i $1 -acodec copy -ss $start_time -to $end_time "$this_track_num - $this_performer - $this_title.$ext"
			index=0
			continue;;
		INDEX\ 01*)
			end_time=$(convert_to_ms ${trim##INDEX\ 01\ })
			[ $index -eq 1 ] && ffmpeg -i $1 -acodec copy -ss $start_time -to $end_time "$this_track_num - $this_performer - $this_title.$ext"
			start_time=$end_time
			this_track_num=$track_num
			this_performer=$performer
			this_title=$title
			index=1
			continue;;
		PERFORMER\ *)
			performer=${trim##PERFORMER\ }
			continue;;
	esac
done < "$2"
#With the way cue files are formatted, they dont tell us when to end the last track, so we have to manually determine
end_time=$(ffprobe -i $1 -show_entries format=duration -v quiet -of csv="p=0" -sexagesimal)
ffmpeg -i $1 -acodec copy -ss $start_time -to $end_time "$this_track_num - $this_performer - $this_title.$ext"


